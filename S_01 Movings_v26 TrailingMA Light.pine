// S_01 Movings_v26 JMA+Sharpe Ratio v4
// TrailingMA Light
// @version=5
strategy(title="S_01 TrailigMA Light",
	 overlay=true,
	 initial_capital=100,
	 currency="USDT",
	 calc_on_order_fills=true,
	 calc_on_every_tick=true,
	 use_bar_magnifier=true,
	 fill_orders_on_standard_ohlc=true,
	 process_orders_on_close=false,
	 default_qty_type=strategy.cash,
	 default_qty_value=100,
	 commission_type=strategy.commission.percent,
	 commission_value=0.05)


// Date Filter
useDateFilter     = input.bool(true, "Date Filer", inline="Use Date Filer")
useDaysFilter     = input.bool(false, "Days Filer", inline="Use Date Filer")
drawTester        = input.bool(title="Backtester", defval=true, inline="Use Date Filer")
comments          = input.string(title="", defval="LINK 15m", inline="Use Date Filer")

tradeMonday       = input.bool(true, "Mon", inline="Days of week")
tradeTuesday      = input.bool(true, "Tue", inline="Days of week")
tradeWednsday     = input.bool(true, "Wed", inline="Days of week")
tradeThursday     = input.bool(true, "Thu", inline="Days of week")
tradeFriday       = input.bool(true, "Fri", inline="Days of week")
tradeSaturday     = input.bool(true, "Sat", inline="Days of week")
tradeSunday       = input.bool(true, "Sun", inline="Days of week")
tradeDaysCloseAll = input.bool(false, "Close All", inline="Days of week")

startDate         = input.time(timestamp('2025-04-01'), title="Start Date")
endDate           = input.time(timestamp('2025-09-01'), title="End Date")


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ INPUTS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// Long or Short Direction + Break Switch + Trend Reverse Switch
tradeLong              = input.bool(title="Long", defval=true, inline="Trade Direction")
tradeShort             = input.bool(title="Short", defval=true, inline="Trade Direction")


// Show MA
var g_ma   = "Moving Averages"
useMA1     = input.bool(defval=false, title="L MA", inline="MA №1", group=g_ma)
useMA2     = input.bool(defval=false, title="S MA", inline="MA №2", group=g_ma)
useMA3     = input.bool(defval=true, title="T MA", inline="MA №3", group=g_ma)

// Get MA Types
maType1    = input.string(title="", defval="KAMA", options=["EMA", "SMA", "JMA", "HMA", "WMA", "ALMA", "KAMA", "TMA", "T3", "DEMA", "VWMA", "VWAP"], inline="MA №1", group=g_ma)
maType2    = input.string(title="", defval="KAMA", options=["EMA", "SMA", "JMA", "HMA", "WMA", "ALMA", "KAMA", "TMA", "T3", "DEMA", "VWMA", "VWAP"], inline="MA №2", group=g_ma)
maType3    = input.string(title="", defval="HMA", options=["EMA", "SMA", "JMA", "HMA", "WMA", "ALMA", "KAMA", "TMA", "T3", "DEMA", "VWMA", "VWAP"], inline="MA №3", group=g_ma)


// Get MA Lengths
maLength1  = input.int(title="", defval=15, minval=0, step=1, inline="MA №1", group=g_ma)
maLength2  = input.int(title="", defval=15, minval=0, step=1, inline="MA №2", group=g_ma)
maLength3  = input.int(title="", defval=150, minval=0, step=1, inline="MA №3", group=g_ma)


// Get MA Colors
maColor1  = input.color(defval=#8eb678, title="", inline="MA №1", group=g_ma)
maColor2  = input.color(defval=#c99686, title="", inline="MA №2", group=g_ma)
maColor3  = input.color(defval=color.rgb(166, 109, 176, 40), title="", inline="MA №3", group=g_ma)


// Trend Moving break or bounce inputs
trendBreak           = input.bool(title="T Break", defval=true, inline="Trend BB", group=g_ma)
closeCountTrendLong  = input.int(title="Long", defval=8, minval=1, step=1, inline="Trend BB", group=g_ma)
closeCountTrendShort = input.int(title="Short", defval=7, minval=1, step=1, inline="Trend BB", group=g_ma)


// Stops + Rewards + Risks inputs
var g_rrs   = ""//"Stops, Rewards, Risks"
stopMultiplierLong        = input.float(title="Stop Long X", defval=1.8, minval=0.1, step=0.1, inline="Long Stop ATR", group=g_rrs)
rrLong                    = input.float(title="RR", defval=3, minval=0.5, step=0.1, inline="Long Stop ATR", group=g_rrs)
lpLong                    = input.int(title="LP", defval=2, inline="Long Stop ATR", group=g_rrs)

stopMultiplierShort       = input.float(title="Stop Short X", defval=2, minval=0.1, step=0.1, inline="Short Stop ATR", group=g_rrs)
rrShort                   = input.float(title="RR", defval=3, minval=0.5, step=0.1, inline="Short Stop ATR", group=g_rrs)
lpShort                   = input.int(title="LP", defval=2, inline="Short Stop ATR", group=g_rrs)

useLongStopPctFilter      = input.bool(defval=true, title="L Stop Max %", inline="StopPctFilter", group=g_rrs)
longStopPctFilterSize     = input.int(defval=3, title="", inline="StopPctFilter", group=g_rrs)

useShortStopPctFilter     = input.bool(defval=true, title="S Stop Max %", inline="StopPctFilter", group=g_rrs)
shortStopPctFilterSize    = input.int(defval=3, title="", inline="StopPctFilter", group=g_rrs)

useLongStopDaysFilter     = input.bool(defval=true, title="L Stop Max D", inline="StopDaysFilter", group=g_rrs)
longStopDaysFilterSize    = input.int(defval=2, minval=1, step=1, title="", inline="StopDaysFilter", group=g_rrs)

useShortStopDaysFilter    = input.bool(defval=true, title="S Stop Max D", inline="StopDaysFilter", group=g_rrs)
shortStopDaysFilterSize   = input.int(defval=4, minval=1, step=1, title="", inline="StopDaysFilter", group=g_rrs)

trailRRLong               = input.float(title="RR TrailingMALong", defval=1, minval=0.5, step=0.1, inline="trailRR", group=g_rrs)

trailRRShort              = input.float(title="RR TrailingMAShort", defval=1, minval=0.5, step=0.1, inline="trailRR", group=g_rrs)

useTrailMALong            = input.bool(defval=true, title="Trail MA Long", inline="Trail Long MA", group=g_rrs)
trailMATypeLong           = input.string(title="", defval="HMA", options=["EMA", "SMA", "JMA", "HMA", "WMA", "ALMA", "KAMA", "TMA", "T3", "DEMA", "VWMA", "VWAP"], inline="Trail Long MA", group=g_rrs)
trailMALengthLong         = input.int(title="", defval=150, minval=0, step=5, inline="Trail Long MA", group=g_rrs)
trailMAOffsetLong         = input.float(title="", defval=-2.5, step=0.5, inline="Trail Long MA", group=g_rrs)

useTrailMAShort           = input.bool(defval=true, title="Trail MA Short", inline="Trail Short MA", group=g_rrs)
trailMATypeShort          = input.string(title="", defval="HMA", options=["EMA", "SMA", "JMA", "HMA", "WMA", "ALMA", "KAMA", "TMA", "T3", "DEMA", "VWMA", "VWAP"], inline="Trail Short MA", group=g_rrs)
trailMALengthShort        = input.int(title="", defval=125, minval=0, step=5, inline="Trail Short MA", group=g_rrs)
trailMAOffsetShort        = input.float(title="", defval=2.5, step=0.5, inline="Trail Short MA", group=g_rrs)

riskPerTrade              = input.float(title="Risk Per Trade", defval=2, step=0.5, inline="Risk Per Trade", group=g_rrs)
contracsSize              = input.float(title="Contract Size", defval=0.01, options=[0.0001, 0.001, 0.01, 0.1, 1, 10, 100, 1000, 10000, 100000, 1000000], inline="Risk Per Trade", group=g_rrs)


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ CALCULATIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// KAMA and T3 inputs 
float fastKama = 2
float slowKama = 30
float factorT3 = 0.7


// Get gd function for T3 Moving Average calculation
gd(_maSource, _maLength) =>
    ta.ema(_maSource, _maLength) * (1 + factorT3) - ta.ema(ta.ema(_maSource, _maLength), _maLength) * factorT3


// Get selected Moving Average
getMA(_maSource, _maType, _maLength) =>
    if _maLength == 0
        na
    else
        switch _maType
            "SMA" => ta.sma(_maSource, _maLength)
            "HMA" => ta.hma(_maSource, _maLength)
            "WMA" => ta.wma(_maSource, _maLength)
            "VWMA" => ta.vwma(_maSource, _maLength)
            "VWAP" => ta.vwap
            "ALMA" => ta.alma(_maSource, _maLength, 0.85, 6)
            "DEMA" =>
                e1 = ta.ema(_maSource, _maLength)
                e2 = ta.ema(e1, _maLength)
                2 * e1 - e2
            "KAMA" =>
                mom = math.abs(ta.change(_maSource, _maLength))
                volatility = math.sum(math.abs(ta.change(_maSource)), _maLength)
                er = volatility != 0 ? mom / volatility : 0
                fastAlpha = 2 / (fastKama + 1)
                slowAlpha = 2 / (slowKama + 1)
                alpha = math.pow(er * (fastAlpha - slowAlpha) + slowAlpha, 2)
                kama = 0.0
                kama := alpha * _maSource + (1 - alpha) * nz(kama[1], _maSource)
                kama
            "TMA" =>
                tma = ta.sma(ta.sma(_maSource, math.ceil(_maLength / 2)), math.floor(_maLength / 2) + 1)
            "T3" =>
                t3 = gd(gd(gd(_maSource, _maLength), _maLength), _maLength)
            "JMA" =>
                float _phase = 50.0
                float _power = 2.0
                float _phaseRatio = _phase < -100 ? 0.5 : _phase > 100 ? 2.5 : _phase / 100 + 1.5
                float _beta  = 0.45 * (_maLength - 1) / (0.45 * (_maLength - 1) + 2)
                float _alpha = math.pow(_beta, _power)
                float _e0 = 0.0
                _e0 := (1 - _alpha) * _maSource + _alpha * nz(_e0[1], _maSource)
                float _e1 = 0.0
                _e1 := (_maSource - _e0) * (1 - _beta) + _beta * nz(_e1[1], 0)
                float _e2  = 0.0
                float _jma = 0.0
                _e2  := (_e0 + _phaseRatio * _e1 - nz(_jma[1], _maSource)) * math.pow(1 - _alpha, 2) + math.pow(_alpha, 2) * nz(_e2[1], 0)
                _jma := _e2 + nz(_jma[1], _maSource)
                _jma
            => ta.ema(_maSource, _maLength)


// Get ATR and MA values
atr             = ta.atr(14)

ma1             = getMA(close, maType1, maLength1)
ma2             = getMA(close, maType2, maLength2)
ma3             = getMA(close, maType3, maLength3)

trailMALong     = if trailMAOffsetLong == 0
    getMA(close, trailMATypeLong, trailMALengthLong)
else if trailMAOffsetLong != 0
    getMA(close, trailMATypeLong, trailMALengthLong) * (1 + trailMAOffsetLong/100)

trailMAShort    = if trailMAOffsetShort == 0
    getMA(close, trailMATypeShort, trailMALengthShort)
else if trailMAOffsetShort != 0
    getMA(close, trailMATypeShort, trailMALengthShort) * (1 + trailMAOffsetShort/100)


// Counters for trend break
var int counterCloseCountTrendLong  = 0
var int counterCloseCountTrendShort = 0

if close > ma3
    counterCloseCountTrendLong := counterCloseCountTrendLong + 1
    counterCloseCountTrendShort := 0
else if close < ma3
    counterCloseCountTrendShort := counterCloseCountTrendShort + 1
    counterCloseCountTrendLong := 0
else
    counterCloseCountTrendLong := 0
    counterCloseCountTrendShort := 0


// Counter long or short trade
var int counterTradeLong  = 0
var int counterTradeShort = 0

if strategy.position_size > 0
    counterTradeLong := 1
    counterTradeShort := 0

if strategy.position_size < 0
    counterTradeLong := 0
    counterTradeShort := 1


// Check trend conditions and break
upTrend = if (useMA3 and not trendBreak)
    close > ma3
else if (useMA3 and trendBreak)
    counterCloseCountTrendLong >= closeCountTrendLong and counterTradeLong == 0
else
    true

downTrend = if (useMA3 and not trendBreak)
    close < ma3
else if (useMA3 and trendBreak)
    counterCloseCountTrendShort >= closeCountTrendShort and counterTradeShort == 0
else
    true


// Check Dates Range
timeInRange = not useDateFilter or time >= startDate and time <= endDate

tradeDays = if useDaysFilter
    (tradeMonday and time(timeframe.period, '0000-0000:2', 'GMT+8')) or 
     (tradeTuesday and time(timeframe.period, '0000-0000:3', 'GMT+8')) or 
     (tradeWednsday and time(timeframe.period, '0000-0000:4', 'GMT+8')) or 
     (tradeThursday and time(timeframe.period, '0000-0000:5', 'GMT+8')) or 
     (tradeFriday and time(timeframe.period, '0000-0000:6', 'GMT+8')) or 
     (tradeSaturday and time(timeframe.period, '0000-0000:7', 'GMT+8')) or 
     (tradeSunday and time(timeframe.period, '0000-0000:1', 'GMT+8'))
else
    true


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ENTRY ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// Check long/short conditions
longConditions  = upTrend and timeInRange and tradeDays and tradeLong and strategy.position_size == 0 and strategy.position_size[1] == 0 and barstate.isconfirmed
shortConditions = downTrend and timeInRange and tradeDays and tradeShort and strategy.position_size == 0 and strategy.position_size[1] == 0 and barstate.isconfirmed


// Calculate stops and targets
stopSizeLong      = atr * stopMultiplierLong
stopSizeShort     = atr * stopMultiplierShort

longStopPrice     = ta.lowest(low, lpLong) - stopSizeLong
longStopDistance  = close - longStopPrice
longTargetPrice   = close + (longStopDistance * rrLong)
longStopPct       = (longStopDistance/close)*100

longStopPctFilter = if useLongStopPctFilter
    longStopPct <= longStopPctFilterSize
else
    true

shortStopPrice    = ta.highest(high, lpShort) + stopSizeShort
shortStopDistance = shortStopPrice - close
shortTargetPrice  = close - (shortStopDistance * rrShort)
shortStopPct      = (shortStopDistance/close)*100

shortStopPctFilter = if useShortStopPctFilter
    shortStopPct <= shortStopPctFilterSize
else
    true


// Save trade price, stop and target
var t_entry           = 0.0
var t_stop            = 0.0
var t_target          = 0.0
var positionSize      = 0.0

var t_trailLong       = 0.0
var t_trailShort      = 0.0
var trailMAPriceLong  = 0.0
var trailMAPriceShort = 0.0

// Enter trade
if longConditions and longStopPctFilter
    t_entry := close
    t_stop := longStopPrice
    t_target := longTargetPrice
    t_trailLong := longStopPrice
    trailMAPriceLong := longStopPrice
    positionSize := math.floor(((strategy.equity * (riskPerTrade/100)) / (close - t_stop)) / contracsSize) * contracsSize
    strategy.entry(id="Long", direction=strategy.long, qty=positionSize)

if shortConditions and shortStopPctFilter
    t_entry := close
    t_stop := shortStopPrice
    t_target := shortTargetPrice
    t_trailShort := shortStopPrice
    trailMAPriceShort := shortStopPrice
    positionSize := math.floor(((strategy.equity * (riskPerTrade/100)) / (t_stop - close)) / contracsSize) * contracsSize
    strategy.entry(id="Short", direction=strategy.short, qty=positionSize)


// Trailing stop MA calculations
var trailMAActivatedLong = 0
var trailMAActivatedShort = 0

if (high >= (t_entry + ((t_entry - t_stop) * trailRRLong)) and strategy.position_size > 0 and useTrailMALong)
    trailMAActivatedLong := 1

if (low <= (t_entry - ((t_stop - t_entry) * trailRRShort)) and strategy.position_size < 0 and useTrailMAShort)
    trailMAActivatedShort := 1

if trailMALong > trailMAPriceLong
    trailMAPriceLong := trailMALong

if trailMAShort < trailMAPriceShort
    trailMAPriceShort := trailMAShort


// Exit trade
if strategy.position_size > 0 and trailMAActivatedLong == 0
    strategy.exit(id="Long Exit", from_entry="Long", limit=t_target, stop=t_stop)
if strategy.position_size > 0 and trailMAActivatedLong == 1
    strategy.exit(id="Long Exit", from_entry="Long", stop=trailMAPriceLong)

if strategy.position_size < 0 and trailMAActivatedShort == 0
    strategy.exit(id="Short Exit", from_entry="Short", limit=t_target, stop=t_stop)
if strategy.position_size < 0 and trailMAActivatedShort == 1
    strategy.exit(id="Short Exit", from_entry="Short", stop=trailMAPriceShort)

if strategy.position_size == 0 and strategy.position_size[1] != 0
    trailMAActivatedLong := 0
    trailMAActivatedShort := 0

if tradeDaysCloseAll and not tradeDays
    strategy.close_all()

// Stop counters
var consecutiveStops    = 0
var maxConsecutiveStops = 0
var maxStopLossPct      = 0.0
var maxStopLossPctSet   = 0.0


// Leverage counter
var leverageSize = 1

if strategy.position_size != 0 and strategy.position_size[1] == 0
    currentLeverageSize = math.ceil((positionSize*close) / strategy.equity)
    if currentLeverageSize > leverageSize
        leverageSize := currentLeverageSize


// Check open and close type (SL/TP)
longStopTriggered      = strategy.position_size[1] > 0 and strategy.position_size == 0 and low <= t_stop[1]
longTakeTriggered      = strategy.position_size[1] > 0 and strategy.position_size == 0 and high >= t_target[1]
shortStopTriggered     = strategy.position_size[1] < 0 and strategy.position_size == 0 and high >= t_stop[1]
shortTakeTriggered     = strategy.position_size[1] < 0 and strategy.position_size == 0 and low <= t_target[1]

entryBarLong           = strategy.position_size[1] == 0 and strategy.position_size > 0
entryBarShort          = strategy.position_size[1] == 0 and strategy.position_size < 0

trailMATriggeredLong   = strategy.position_size[1] > 0 and strategy.position_size == 0 and low <= trailMAPriceLong[1] and trailMAActivatedLong[1] == 1
trailMATriggeredShort  = strategy.position_size[1] < 0 and strategy.position_size == 0 and high >= trailMAPriceShort[1] and trailMAActivatedShort[1] == 1

trailTriggeredLongProfit  = (trailMATriggeredLong and trailMAPriceLong > t_entry)
trailTriggeredLongLoss    = (trailMATriggeredLong and trailMAPriceLong < t_entry)
trailTriggeredShortProfit = (trailMATriggeredShort and trailMAPriceShort < t_entry)
trailTriggeredShortLoss   = (trailMATriggeredShort and trailMAPriceShort > t_entry)


// Calculate stop percent
calcStopPct(entryPrice, stopPrice, isLong) =>
    math.abs(entryPrice - stopPrice) / entryPrice * 100


// Update stop counters
if longStopTriggered
    stopPct = calcStopPct(t_entry[1], t_stop[1], true)
    if stopPct > maxStopLossPct
        maxStopLossPct := stopPct
    consecutiveStops += 1
    if consecutiveStops > maxConsecutiveStops
        maxConsecutiveStops := consecutiveStops
        
if shortStopTriggered
    stopPct = calcStopPct(t_entry[1], t_stop[1], false)
    if stopPct > maxStopLossPct
        maxStopLossPct := stopPct
    consecutiveStops += 1
    if consecutiveStops > maxConsecutiveStops
        maxConsecutiveStops := consecutiveStops

if longConditions and longStopPctFilter
    if longStopPct > maxStopLossPctSet
        maxStopLossPctSet := longStopPct

if shortConditions and shortStopPctFilter
    if shortStopPct > maxStopLossPctSet
        maxStopLossPctSet := shortStopPct

if longTakeTriggered or shortTakeTriggered
    consecutiveStops := 0


// Days counters
var int entryTime = na
var float maxDaysInTrade = 0.0

if strategy.opentrades > 0 and na(entryTime)
    entryTime := time

if strategy.opentrades > 0 and not na(entryTime)
    daysInTrade = (time - entryTime) / (1000 * 60 * 60 * 24)
    if daysInTrade > maxDaysInTrade
        maxDaysInTrade := daysInTrade

if strategy.opentrades == 0 and not na(entryTime)
    entryTime := na

// Days Filters
var int   longEntryTime  = na
var int   shortEntryTime = na
var int   longDays       = 0
var int   shortDays      = 0

if strategy.position_size > 0 and strategy.position_size[1] == 0
    longEntryTime := time
    longDays := 0
if strategy.position_size <= 0 and strategy.position_size[1] > 0
    longEntryTime := na
    longDays := 0

if strategy.position_size < 0 and strategy.position_size[1] == 0
    shortEntryTime := time
    shortDays := 0
if strategy.position_size >= 0 and strategy.position_size[1] < 0
    shortEntryTime := na
    shortDays := 0

if strategy.position_size > 0 and not na(longEntryTime)
    longDays := int(math.floor((time - longEntryTime) / 86400000.0))
else
    longDays := 0

if strategy.position_size < 0 and not na(shortEntryTime)
    shortDays := int(math.floor((time - shortEntryTime) / 86400000.0))
else
    shortDays := 0

longStopDaysFilter = if useLongStopDaysFilter and longDays >= longStopDaysFilterSize
    true
shortStopDaysFilter = if useShortStopDaysFilter and shortDays >= shortStopDaysFilterSize
    true

if useLongStopDaysFilter and longDays >= longStopDaysFilterSize
    strategy.close("Long")

if useShortStopDaysFilter and shortDays >= shortStopDaysFilterSize
    strategy.close("Short")

// Draw MAs
plot(not useMA1 ? na : ma1, color=maColor1, linewidth=1, title="MA №1")
plot(not useMA2 ? na : ma2, color=maColor2, linewidth=1, title="MA №2")
plot(not useMA3 ? na : ma3, color=maColor3, linewidth=2, title="MA №3")
plot(trailMAActivatedLong == 1 ? trailMAPriceLong : na, color=color.red, style=plot.style_linebr, linewidth=1, title="trailMAPriceLong")
plot(trailMAActivatedShort == 1 ? trailMAPriceShort : na, color=color.red, style=plot.style_linebr, linewidth=1, title="trailMAPriceShort")


// Draw stops and targets
plot(strategy.position_size != 0 ? t_entry : na, title="Entry Price", color=color.blue, style=plot.style_linebr, transp=50)
plot((strategy.position_size != 0 or longConditions or shortConditions) and (trailMAActivatedLong == 0 and trailMAActivatedShort == 0) ? t_stop : na, title="Trade Stop Price", color=color.red, style=plot.style_linebr)
plot(strategy.position_size != 0 or longConditions or shortConditions ? t_target : na, title="Trade Target Price", color=color.green, style=plot.style_linebr)
plotshape(longStopTriggered, style=shape.circle, location=location.top, color=color.red, size=size.tiny)
plotshape(shortStopTriggered, style=shape.circle, location=location.top, color=color.red, size=size.tiny)
plotshape(longTakeTriggered, style=shape.circle, location=location.top, color=color.green, size=size.tiny)
plotshape(shortTakeTriggered, style=shape.circle, location=location.top, color=color.green, size=size.tiny)
plotshape(entryBarLong, style=shape.circle, location=location.top, color=color.gray, size=size.tiny, transp=80)
plotshape(entryBarShort, style=shape.circle, location=location.top, color=color.gray, size=size.tiny, transp=80)
plotshape(longStopDaysFilter or shortStopDaysFilter, style=shape.circle, location=location.top, color=color.fuchsia, size=size.tiny)
plotshape(trailTriggeredLongProfit or trailTriggeredShortProfit, style=shape.circle, location=location.top, color=color.green, size=size.tiny)
plotshape(trailTriggeredLongLoss or trailTriggeredShortLoss, style=shape.circle, location=location.top, color=color.orange, size=size.tiny, transp=40)


// Sharpe Ratio Calculations v4 - перенесенный из Python скрипта S_03_Light+Grid_v03 Sharpe+Filter Netprofit.py
var float   _sr_monthStartEq = na
var array<float> _sr_mR      = array.new_float()
var bool    _sr_prevInRange  = false
var bool    _sr_dirty        = false

_sr_entered = not _sr_prevInRange and timeInRange
_sr_left    = _sr_prevInRange and not timeInRange
_sr_prevInRange := timeInRange

if _sr_entered
    _sr_monthStartEq := strategy.initial_capital
    array.clear(_sr_mR)
    _sr_dirty := true

if timeInRange and bar_index > 0 and month(time) != month(time[1])
    float _sr_lastEqPrevMonth = strategy.equity[1]  // equity at last bar of previous month
    if _sr_monthStartEq > 0
        array.push(_sr_mR, ((_sr_lastEqPrevMonth / _sr_monthStartEq) - 1.0) * 100.0)
        _sr_dirty := true
    _sr_monthStartEq := _sr_lastEqPrevMonth

f_pop_stdev(arr) =>
    int _n = array.size(arr)
    if _n == 0
        na
    else
        float _mean = array.avg(arr)
        float _s = 0.0
        for i = 0 to _n - 1
            float _d = array.get(arr, i) - _mean
            _s += _d * _d
        math.sqrt(_s / _n)

var float _sharpe = na
if _sr_dirty
    int _sr_n = array.size(_sr_mR)
    if _sr_n >= 2
        float _avg  = array.avg(_sr_mR)
        float _sd   = f_pop_stdev(_sr_mR)                 // population stdev (ddof=0)
        float _rfrm = (0.02 * 100.0) / 12.0              // 2% annual -> monthly percent
        if not na(_sd) and _sd != 0
            _sharpe := (_avg - _rfrm) / _sd
        else
            _sharpe := na
    else
        _sharpe := na
    _sr_dirty := false



// Prepare stats table
var table testTable = table.new(position.bottom_left, 2, 5, border_width=1, border_color=color.black, frame_color=color.black, frame_width=1)
f_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>
    _cellText = _title + "\n" + _value
    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor)


// Draw stats table
var bgcolor = #f3f3f3
if drawTester
    f_fillCell(testTable, 0, 0, "WR:", str.tostring(math.floor(strategy.wintrades / strategy.closedtrades * 100)) + "%", bgcolor, (math.floor(strategy.wintrades / strategy.closedtrades * 100)) > 45 ? #6caf5d : color.black)
    f_fillCell(testTable, 1, 0, "PnL:", str.tostring(math.floor(strategy.netprofit_percent)) + "%", bgcolor, (math.floor(strategy.netprofit_percent)) <= 0 ? #a73302 : color.black)
    f_fillCell(testTable, 0, 1, "DD:", str.tostring(math.ceil(strategy.max_drawdown_percent)) + "%", bgcolor, (math.ceil(strategy.max_drawdown_percent)) > 20 ? #a73302 : color.black)
    f_fillCell(testTable, 1, 1, "Trades:", str.tostring(strategy.closedtrades), bgcolor, color.black)
    f_fillCell(testTable, 1, 2, "SL:", str.tostring(consecutiveStops), bgcolor, consecutiveStops >= 3 ? #a73302 : color.black)
    f_fillCell(testTable, 0, 2, "Max SL:", str.tostring(maxConsecutiveStops), bgcolor, maxConsecutiveStops > 5 ? #a73302 : color.black)
    f_fillCell(testTable, 0, 3, "Max SL:", str.tostring(math.ceil(maxStopLossPctSet)) + "%", bgcolor, maxStopLossPctSet >= 10 ? #a73302 : color.black)
    f_fillCell(testTable, 1, 3, "Lev:", str.tostring(leverageSize), bgcolor, leverageSize >= 10 ? #a73302 : color.black)
    f_fillCell(testTable, 0, 4, "Max D:", str.tostring(math.ceil(maxDaysInTrade)), bgcolor, color.black)
    f_fillCell(testTable, 1, 4, "Sharpe:", na(_sharpe) ? "" : str.tostring(math.floor(_sharpe * 100) / 100.0), bgcolor, color.black)
