// S_01 Movings_v26 JMA+Sharpe Ratio v4
// TrailingMA Light
// @version=5
strategy(title="S_01 TrailingMA Ultralight",
	 overlay=true,
	 initial_capital=100,
	 currency="USDT",
     pyramiding=0,
	 calc_on_order_fills=true,
	 calc_on_every_tick=true,
	 use_bar_magnifier=true,
	 fill_orders_on_standard_ohlc=true,
	 process_orders_on_close=false,
	 default_qty_type=strategy.cash,
	 default_qty_value=100,
	 commission_type=strategy.commission.percent,
	 commission_value=0.05)


// Backtesting range Date Filter
useDateFilter     = input.bool(true, "Date Filter", inline="Use Date Filter")
startDate         = input.time(timestamp('2025-04-01'), title="Start Date")
endDate           = input.time(timestamp('2025-09-01'), title="End Date")

drawTester        = input.bool(title="Backtester", defval=true, inline="Use Date Filter") // Drawing mini table with stats

// Trend moving average
maType3    = input.string(title="T MA Type", defval="EMA", options=["EMA", "SMA", "HMA", "WMA", "ALMA", "KAMA", "TMA", "T3", "DEMA", "VWMA", "VWAP"], inline="MA №3")
maLength3  = input.int(title="Length", defval=45, minval=0, step=1, inline="MA №3")
maColor3  = input.color(defval=color.rgb(166, 109, 176, 40), title="", inline="MA №3")

// Trend break - how many closes above or below Trend moving average
closeCountTrendLong  = input.int(title="Close Count Long", defval=7, minval=1, step=1, inline="Trend BB")
closeCountTrendShort = input.int(title="Close Count Short", defval=5, minval=1, step=1, inline="Trend BB")


// Initial stop loss, Risk reward and lookback period settings
stopMultiplierLong        = input.float(title="Stop Long X", defval=2.0, minval=0.1, step=0.1, inline="Long Stop ATR", group="Stops and Filters")
rrLong                    = input.float(title="RR", defval=3, minval=0.5, step=0.1, inline="Long Stop ATR", group="Stops and Filters")
lpLong                    = input.int(title="LP", defval=2, inline="Long Stop ATR", group="Stops and Filters")

stopMultiplierShort       = input.float(title="Stop Short X", defval=2, minval=0.1, step=0.1, inline="Short Stop ATR", group="Stops and Filters")
rrShort                   = input.float(title="RR", defval=3, minval=0.5, step=0.1, inline="Short Stop ATR", group="Stops and Filters")
lpShort                   = input.int(title="LP", defval=2, inline="Short Stop ATR", group="Stops and Filters")

// Max stop loss percent filter - if calculated stop loss is greater than the value specified here, the entry signal is skipped
longStopPctFilterSize     = input.int(defval=3, title="L Stop Max %", inline="StopPctFilter", group="Stops and Filters")
shortStopPctFilterSize    = input.int(defval=3, title="S Stop Max %", inline="StopPctFilter", group="Stops and Filters")

// Max days in trade - if position is held for more than the numbers of days specified here, forcibly close position at market
longStopDaysFilterSize    = input.int(defval=2, minval=1, step=1, title="L Stop Max D", inline="StopDaysFilter", group="Stops and Filters")
shortStopDaysFilterSize   = input.int(defval=4, minval=1, step=1, title="S Stop Max D", inline="StopDaysFilter", group="Stops and Filters")


// Trailing stop settings - trailing stop activates when price reaches trailRRLong (for long position) or trailRRShort (for short position) level
// After activation, stop moves according to selected moving average (trailMATypeLong or trailMATypeShort) with offset (negative offset for long position, positive for short position)
// When activated - use trailing stop instead of the initial stop loss and take profit
trailRRLong               = input.float(title="Trail RR Long", defval=1, minval=0.5, step=0.1, inline="Trail RR", group="Trailing Stops")
trailRRShort              = input.float(title="Trail RR Short", defval=1, minval=0.5, step=0.1, inline="Trail RR", group="Trailing Stops")

trailMATypeLong           = input.string(title="Trail MA Long", defval="SMA", options=["EMA", "SMA", "HMA", "WMA", "ALMA", "KAMA", "TMA", "T3", "DEMA", "VWMA", "VWAP"], inline="Trail Long MA", group="Trailing Stops")
trailMALengthLong         = input.int(title="", defval=160, minval=0, step=5, inline="Trail Long MA", group="Trailing Stops")
trailMAOffsetLong         = input.float(title="", defval=-1.0, step=0.5, inline="Trail Long MA", group="Trailing Stops") // WARNING - default trailing long offset value is NEGATIVE, it's "minus 1.0"

trailMATypeShort          = input.string(title="Trail MA Short", defval="SMA", options=["EMA", "SMA", "HMA", "WMA", "ALMA", "KAMA", "TMA", "T3", "DEMA", "VWMA", "VWAP"], inline="Trail Short MA", group="Trailing Stops")
trailMALengthShort        = input.int(title="", defval=160, minval=0, step=5, inline="Trail Short MA", group="Trailing Stops")
trailMAOffsetShort        = input.float(title="", defval=1.0, step=0.5, inline="Trail Short MA", group="Trailing Stops")

riskPerTrade              = input.float(title="Risk Per Trade", defval=2, step=0.5, inline="Risk Per Trade")
contractsSize             = input.float(title="Contract Size", defval=0.01, options=[0.0001, 0.001, 0.01, 0.1, 1, 10, 100, 1000, 10000, 100000, 1000000], inline="Risk Per Trade")


// Values for KAMA and T3 calculations
float fastKama = 2
float slowKama = 30
float factorT3 = 0.7

// gd function for T3 Moving Average calculation
gd(_maSource, _maLength) =>
    ta.ema(_maSource, _maLength) * (1 + factorT3) - ta.ema(ta.ema(_maSource, _maLength), _maLength) * factorT3

// Get selected Moving Average function
getMA(_maSource, _maType, _maLength) =>
    if _maLength == 0
        na
    else
        switch _maType
            "SMA" => ta.sma(_maSource, _maLength)
            "HMA" => ta.hma(_maSource, _maLength)
            "WMA" => ta.wma(_maSource, _maLength)
            "VWMA" => ta.vwma(_maSource, _maLength)
            "VWAP" => ta.vwap
            "ALMA" => ta.alma(_maSource, _maLength, 0.85, 6)
            "DEMA" =>
                e1 = ta.ema(_maSource, _maLength)
                e2 = ta.ema(e1, _maLength)
                2 * e1 - e2
            "KAMA" =>
                mom = math.abs(ta.change(_maSource, _maLength))
                volatility = math.sum(math.abs(ta.change(_maSource)), _maLength)
                er = volatility != 0 ? mom / volatility : 0
                fastAlpha = 2 / (fastKama + 1)
                slowAlpha = 2 / (slowKama + 1)
                alpha = math.pow(er * (fastAlpha - slowAlpha) + slowAlpha, 2)
                kama = 0.0
                kama := alpha * _maSource + (1 - alpha) * nz(kama[1], _maSource)
                kama
            "TMA" =>
                tma = ta.sma(ta.sma(_maSource, math.ceil(_maLength / 2)), math.floor(_maLength / 2) + 1)
            "T3" =>
                t3 = gd(gd(gd(_maSource, _maLength), _maLength), _maLength)
            => ta.ema(_maSource, _maLength)


// Get ATR and MA values
atr             = ta.atr(14)

ma3             = getMA(close, maType3, maLength3)

trailMALong     = if trailMAOffsetLong == 0
    getMA(close, trailMATypeLong, trailMALengthLong)
else if trailMAOffsetLong != 0
    getMA(close, trailMATypeLong, trailMALengthLong) * (1 + trailMAOffsetLong/100)

trailMAShort    = if trailMAOffsetShort == 0
    getMA(close, trailMATypeShort, trailMALengthShort)
else if trailMAOffsetShort != 0
    getMA(close, trailMATypeShort, trailMALengthShort) * (1 + trailMAOffsetShort/100)

// Counters for trend break
var int counterCloseCountTrendLong  = 0
var int counterCloseCountTrendShort = 0

if close > ma3
    counterCloseCountTrendLong := counterCloseCountTrendLong + 1
    counterCloseCountTrendShort := 0
else if close < ma3
    counterCloseCountTrendShort := counterCloseCountTrendShort + 1
    counterCloseCountTrendLong := 0
else
    counterCloseCountTrendLong := 0
    counterCloseCountTrendShort := 0

// A flag indicating whether the position was long or short - after closing position, we switch the position side (long → short → long → …)
var int counterTradeLong  = 0
var int counterTradeShort = 0

if strategy.position_size > 0
    counterTradeLong := 1
    counterTradeShort := 0

if strategy.position_size < 0
    counterTradeLong := 0
    counterTradeShort := 1

// Check trend break conditions
upTrend = counterCloseCountTrendLong >= closeCountTrendLong and counterTradeLong == 0
downTrend = counterCloseCountTrendShort >= closeCountTrendShort and counterTradeShort == 0

// Check Dates Range
timeInRange = not useDateFilter or time >= startDate and time <= endDate

// Check long/short conditions
longConditions  = upTrend and timeInRange and strategy.position_size == 0 and strategy.position_size[1] == 0 and barstate.isconfirmed
shortConditions = downTrend and timeInRange and strategy.position_size == 0 and strategy.position_size[1] == 0 and barstate.isconfirmed


// Calculate stops, targets and stop percent filters
stopSizeLong      = atr * stopMultiplierLong
stopSizeShort     = atr * stopMultiplierShort

longStopPrice     = ta.lowest(low, lpLong) - stopSizeLong
longStopDistance  = close - longStopPrice
longTargetPrice   = close + (longStopDistance * rrLong)
longStopPct       = (longStopDistance/close)*100

longStopPctFilter = longStopPct <= longStopPctFilterSize

shortStopPrice    = ta.highest(high, lpShort) + stopSizeShort
shortStopDistance = shortStopPrice - close
shortTargetPrice  = close - (shortStopDistance * rrShort)
shortStopPct      = (shortStopDistance/close)*100

shortStopPctFilter = shortStopPct <= shortStopPctFilterSize


// Save trade entry price, stop, target and position size
var t_entry           = 0.0
var t_stop            = 0.0
var t_target          = 0.0
var positionSize      = 0.0

var t_trailLong       = 0.0
var t_trailShort      = 0.0
var trailMAPriceLong  = 0.0
var trailMAPriceShort = 0.0

// Enter long trade if longConditions are met and long stop loss percent filter is in range
if longConditions and longStopPctFilter
    t_entry := close
    t_stop := longStopPrice
    t_target := longTargetPrice
    trailMAPriceLong := longStopPrice
    positionSize := math.floor(((strategy.equity * (riskPerTrade/100)) / (close - t_stop)) / contractsSize) * contractsSize
    strategy.entry(id="Long", direction=strategy.long, qty=positionSize)

// Enter short trade if shortConditions are met and short stop loss percent filter is in range
if shortConditions and shortStopPctFilter
    t_entry := close
    t_stop := shortStopPrice
    t_target := shortTargetPrice
    trailMAPriceShort := shortStopPrice
    positionSize := math.floor(((strategy.equity * (riskPerTrade/100)) / (t_stop - close)) / contractsSize) * contractsSize
    strategy.entry(id="Short", direction=strategy.short, qty=positionSize)


// Moving average based trailing stop activation flags
var trailMAActivatedLong = 0
var trailMAActivatedShort = 0

if (high >= (t_entry + ((t_entry - t_stop) * trailRRLong)) and strategy.position_size > 0)
    trailMAActivatedLong := 1

if (low <= (t_entry - ((t_stop - t_entry) * trailRRShort)) and strategy.position_size < 0)
    trailMAActivatedShort := 1

// Update MA based trailing stop condition
if trailMALong > trailMAPriceLong
    trailMAPriceLong := trailMALong

if trailMAShort < trailMAPriceShort
    trailMAPriceShort := trailMAShort

// Exit trade
if strategy.position_size > 0 and trailMAActivatedLong == 0
    strategy.exit(id="Long Exit", from_entry="Long", limit=t_target, stop=t_stop)
if strategy.position_size > 0 and trailMAActivatedLong == 1
    strategy.exit(id="Long Exit", from_entry="Long", stop=trailMAPriceLong)

if strategy.position_size < 0 and trailMAActivatedShort == 0
    strategy.exit(id="Short Exit", from_entry="Short", limit=t_target, stop=t_stop)
if strategy.position_size < 0 and trailMAActivatedShort == 1
    strategy.exit(id="Short Exit", from_entry="Short", stop=trailMAPriceShort)

if strategy.position_size == 0 and strategy.position_size[1] != 0
    trailMAActivatedLong := 0
    trailMAActivatedShort := 0


// Counters for stats in mini table
var consecutiveStops    = 0
var maxConsecutiveStops = 0
var maxStopLossPct      = 0.0
var maxStopLossPctSet   = 0.0

// Check open and close type (SL/TP)
longStopTriggered      = strategy.position_size[1] > 0 and strategy.position_size == 0 and low <= t_stop[1]
longTakeTriggered      = strategy.position_size[1] > 0 and strategy.position_size == 0 and high >= t_target[1]
shortStopTriggered     = strategy.position_size[1] < 0 and strategy.position_size == 0 and high >= t_stop[1]
shortTakeTriggered     = strategy.position_size[1] < 0 and strategy.position_size == 0 and low <= t_target[1]

entryBarLong           = strategy.position_size[1] == 0 and strategy.position_size > 0
entryBarShort          = strategy.position_size[1] == 0 and strategy.position_size < 0

trailMATriggeredLong   = strategy.position_size[1] > 0 and strategy.position_size == 0 and low <= trailMAPriceLong[1] and trailMAActivatedLong[1] == 1
trailMATriggeredShort  = strategy.position_size[1] < 0 and strategy.position_size == 0 and high >= trailMAPriceShort[1] and trailMAActivatedShort[1] == 1

trailTriggeredLongProfit  = trailMATriggeredLong and trailMAPriceLong > t_entry
trailTriggeredLongLoss    = trailMATriggeredLong and trailMAPriceLong < t_entry
trailTriggeredShortProfit = trailMATriggeredShort and trailMAPriceShort < t_entry
trailTriggeredShortLoss   = trailMATriggeredShort and trailMAPriceShort > t_entry

// Calculate stop percent function (for stats)
calcStopPct(entryPrice, stopPrice, isLong) =>
    math.abs(entryPrice - stopPrice) / entryPrice * 100

// Update stop counters for stats
if longStopTriggered
    stopPct = calcStopPct(t_entry[1], t_stop[1], true)
    if stopPct > maxStopLossPct
        maxStopLossPct := stopPct
    consecutiveStops += 1
    if consecutiveStops > maxConsecutiveStops
        maxConsecutiveStops := consecutiveStops
        
if shortStopTriggered
    stopPct = calcStopPct(t_entry[1], t_stop[1], false)
    if stopPct > maxStopLossPct
        maxStopLossPct := stopPct
    consecutiveStops += 1
    if consecutiveStops > maxConsecutiveStops
        maxConsecutiveStops := consecutiveStops

if longConditions and longStopPctFilter
    if longStopPct > maxStopLossPctSet
        maxStopLossPctSet := longStopPct

if shortConditions and shortStopPctFilter
    if shortStopPct > maxStopLossPctSet
        maxStopLossPctSet := shortStopPct

if longTakeTriggered or shortTakeTriggered
    consecutiveStops := 0

// Days counters for stats - maximum days we were in any trade
var int entryTime = na
var float maxDaysInTrade = 0.0

if strategy.opentrades > 0 and na(entryTime)
    entryTime := time

if strategy.opentrades > 0 and not na(entryTime)
    daysInTrade = (time - entryTime) / (1000 * 60 * 60 * 24)
    if daysInTrade > maxDaysInTrade
        maxDaysInTrade := daysInTrade

if strategy.opentrades == 0 and not na(entryTime)
    entryTime := na

// Days Filters calculations - how many days we were in long or short trade
var int   longEntryTime  = na
var int   shortEntryTime = na
var int   longDays       = 0
var int   shortDays      = 0

if strategy.position_size > 0 and strategy.position_size[1] == 0
    longEntryTime := time
    longDays := 0
if strategy.position_size <= 0 and strategy.position_size[1] > 0
    longEntryTime := na
    longDays := 0

if strategy.position_size < 0 and strategy.position_size[1] == 0
    shortEntryTime := time
    shortDays := 0
if strategy.position_size >= 0 and strategy.position_size[1] < 0
    shortEntryTime := na
    shortDays := 0

if strategy.position_size > 0 and not na(longEntryTime)
    longDays := int(math.floor((time - longEntryTime) / 86400000.0))
else
    longDays := 0

if strategy.position_size < 0 and not na(shortEntryTime)
    shortDays := int(math.floor((time - shortEntryTime) / 86400000.0))
else
    shortDays := 0

longStopDaysFilter = if longDays >= longStopDaysFilterSize
    true
shortStopDaysFilter = if shortDays >= shortStopDaysFilterSize
    true

// Force-close position at market after max holding days reached
if longDays >= longStopDaysFilterSize
    strategy.close("Long")

if shortDays >= shortStopDaysFilterSize
    strategy.close("Short")

// Drawing and plotting
plot(ma3, color=maColor3, linewidth=2, title="MA №3")
plot(trailMAActivatedLong == 1 ? trailMAPriceLong : na, color=color.red, style=plot.style_linebr, linewidth=1, title="trailMAPriceLong")
plot(trailMAActivatedShort == 1 ? trailMAPriceShort : na, color=color.red, style=plot.style_linebr, linewidth=1, title="trailMAPriceShort")
plot(strategy.position_size != 0 ? t_entry : na, title="Entry Price", color=color.blue, style=plot.style_linebr, transp=50)
plot((strategy.position_size != 0 or longConditions or shortConditions) and (trailMAActivatedLong == 0 and trailMAActivatedShort == 0) ? t_stop : na, title="Trade Stop Price", color=color.red, style=plot.style_linebr)
plot(strategy.position_size != 0 or longConditions or shortConditions ? t_target : na, title="Trade Target Price", color=color.green, style=plot.style_linebr)
plotshape(longStopTriggered, style=shape.circle, location=location.top, color=color.red, size=size.tiny)
plotshape(shortStopTriggered, style=shape.circle, location=location.top, color=color.red, size=size.tiny)
plotshape(longTakeTriggered, style=shape.circle, location=location.top, color=color.green, size=size.tiny)
plotshape(shortTakeTriggered, style=shape.circle, location=location.top, color=color.green, size=size.tiny)
plotshape(entryBarLong, style=shape.circle, location=location.top, color=color.gray, size=size.tiny, transp=80)
plotshape(entryBarShort, style=shape.circle, location=location.top, color=color.gray, size=size.tiny, transp=80)
plotshape(longStopDaysFilter or shortStopDaysFilter, style=shape.circle, location=location.top, color=color.fuchsia, size=size.tiny)
plotshape(trailTriggeredLongProfit or trailTriggeredShortProfit, style=shape.circle, location=location.top, color=color.green, size=size.tiny)
plotshape(trailTriggeredLongLoss or trailTriggeredShortLoss, style=shape.circle, location=location.top, color=color.orange, size=size.tiny, transp=40)


// Sharpe Ratio Calculations v4 - from Python script S_03_Light+Grid_v03 Sharpe+Filter Netprofit.py
var float   _sr_monthStartEq = na
var array<float> _sr_mR      = array.new_float()
var bool    _sr_prevInRange  = false
var bool    _sr_dirty        = false

_sr_entered = not _sr_prevInRange and timeInRange
_sr_left    = _sr_prevInRange and not timeInRange
_sr_prevInRange := timeInRange

if _sr_entered
    _sr_monthStartEq := strategy.initial_capital
    array.clear(_sr_mR)
    _sr_dirty := true

if timeInRange and bar_index > 0 and month(time) != month(time[1])
    float _sr_lastEqPrevMonth = strategy.equity[1]  // equity at last bar of previous month
    if _sr_monthStartEq > 0
        array.push(_sr_mR, ((_sr_lastEqPrevMonth / _sr_monthStartEq) - 1.0) * 100.0)
        _sr_dirty := true
    _sr_monthStartEq := _sr_lastEqPrevMonth

f_pop_stdev(arr) =>
    int _n = array.size(arr)
    if _n == 0
        na
    else
        float _mean = array.avg(arr)
        float _s = 0.0
        for i = 0 to _n - 1
            float _d = array.get(arr, i) - _mean
            _s += _d * _d
        math.sqrt(_s / _n)

var float _sharpe = na
if _sr_dirty
    int _sr_n = array.size(_sr_mR)
    if _sr_n >= 2
        float _avg  = array.avg(_sr_mR)
        float _sd   = f_pop_stdev(_sr_mR)                 // population stdev (ddof=0)
        float _rfrm = (0.02 * 100.0) / 12.0              // 2% annual -> monthly percent
        if not na(_sd) and _sd != 0
            _sharpe := (_avg - _rfrm) / _sd
        else
            _sharpe := na
    else
        _sharpe := na
    _sr_dirty := false



// Prepare stats mini table
var table testTable = table.new(position.bottom_left, 2, 5, border_width=1, border_color=color.black, frame_color=color.black, frame_width=1)
f_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>
    _cellText = _title + "\n" + _value
    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor)


// Draw stats table
var bgcolor = #f3f3f3
if drawTester
    f_fillCell(testTable, 0, 0, "WR:", str.tostring(math.floor(strategy.wintrades / strategy.closedtrades * 100)) + "%", bgcolor, (math.floor(strategy.wintrades / strategy.closedtrades * 100)) > 45 ? #6caf5d : color.black)
    f_fillCell(testTable, 1, 0, "PnL:", str.tostring(math.floor(strategy.netprofit_percent)) + "%", bgcolor, (math.floor(strategy.netprofit_percent)) <= 0 ? #a73302 : color.black)
    f_fillCell(testTable, 0, 1, "DD:", str.tostring(math.ceil(strategy.max_drawdown_percent)) + "%", bgcolor, (math.ceil(strategy.max_drawdown_percent)) > 20 ? #a73302 : color.black)
    f_fillCell(testTable, 1, 1, "Trades:", str.tostring(strategy.closedtrades), bgcolor, color.black)
    f_fillCell(testTable, 1, 2, "SL:", str.tostring(consecutiveStops), bgcolor, consecutiveStops >= 3 ? #a73302 : color.black)
    f_fillCell(testTable, 0, 2, "Max SL:", str.tostring(maxConsecutiveStops), bgcolor, maxConsecutiveStops > 5 ? #a73302 : color.black)
    f_fillCell(testTable, 0, 3, "Max SL:", str.tostring(math.ceil(maxStopLossPctSet)) + "%", bgcolor, maxStopLossPctSet >= 10 ? #a73302 : color.black)
    f_fillCell(testTable, 0, 4, "Max D:", str.tostring(math.ceil(maxDaysInTrade)), bgcolor, color.black)
    f_fillCell(testTable, 1, 4, "Sharpe:", na(_sharpe) ? "" : str.tostring(math.floor(_sharpe * 100) / 100.0), bgcolor, color.black)
